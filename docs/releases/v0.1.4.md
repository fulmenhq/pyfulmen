# PyFulmen v0.1.4 Release Notes

**Release Date**: October 21, 2025
**Release Type**: Feature Release - Unified Asset Access & Documentation Processing
**Milestone**: Crucible Bridge API & Docscribe Module Complete

---

## üéØ Release Overview

PyFulmen v0.1.4 introduces the **Crucible Bridge API** for unified asset access and the **Docscribe Module** for documentation processing with frontmatter parsing. This release simplifies how applications interact with embedded Crucible assets and provides powerful tools for working with markdown documentation programmatically.

**Key Capabilities**:

- **Crucible Bridge API**: Single, unified interface for discovering and accessing all Crucible assets (docs, schemas, config)
- **Docscribe Module**: Frontmatter parsing, format detection, header extraction, and outline generation for markdown documents
- **Asset Discovery**: Recursive category exploration with prefix filtering and similarity-based suggestions
- **Clean Documentation Access**: Frontmatter-stripped markdown for rendering engines
- **Crucible Overview**: Mandatory documentation explaining SSOT role per helper library standard
- **845 Tests Passing**: 113 new tests for bridge and docscribe (18 skipped)

This release prioritizes:

- **Developer Experience**: Simple, intuitive APIs for common Crucible asset operations
- **Documentation Processing**: First-class support for frontmatter, headers, and document structure
- **API Consolidation**: Recommended bridge pattern replaces multiple legacy APIs
- **Backward Compatibility**: All existing APIs maintained unchanged

---

## ‚ú® Major Features

### Crucible Bridge API

Unified interface for accessing all embedded Crucible assets with intelligent discovery and error handling.

#### Core Features

**Location**: `src/pyfulmen/crucible/bridge.py`

- **Asset Discovery**: List categories, enumerate assets with prefix filtering
- **Unified Loading**: Single API for schemas, configs, and documentation
- **Smart Suggestions**: Similarity-based asset ID suggestions on errors
- **Streaming Support**: Context manager for large asset files
- **Version Tracking**: Embedded Crucible version metadata
- **Recursive Discovery**: Automatic scanning of nested schema/config directories

#### Asset Discovery API

**Location**: `src/pyfulmen/crucible/__init__.py`

```python
from pyfulmen import crucible

# Discover available categories
categories = crucible.list_categories()
# Returns: ['docs', 'schemas', 'config']

# List all schemas with optional prefix filter
schemas = crucible.list_assets('schemas')
# Returns all schema asset IDs

# Filter by prefix
foundry_schemas = crucible.list_assets('schemas', prefix='library/foundry')
# Returns: ['library/foundry/v1.0.0/mime-types', ...]

# Get Crucible version metadata
version = crucible.get_crucible_version()
print(f"Crucible {version.version} (commit: {version.commit_hash[:7]})")
```

**AssetMetadata Model**:

```python
class AssetMetadata(FulmenDataModel):
    """Metadata about a discovered asset."""
    asset_id: str  # Full asset identifier
    category: str  # 'docs', 'schemas', or 'config'
    path: Path  # Absolute path to asset file
    size: int  # File size in bytes
    modified: datetime  # Last modification time
```

**CrucibleVersion Model**:

```python
class CrucibleVersion(FulmenDataModel):
    """Embedded Crucible version information."""
    version: str  # Semantic version (e.g., "0.2.1")
    commit_hash: str  # Git commit hash
    sync_timestamp: datetime  # When assets were synced
```

#### Unified Loading API

**Location**: `src/pyfulmen/crucible/bridge.py`

```python
from pyfulmen import crucible

# Load schema by full ID
schema = crucible.load_schema_by_id('observability/logging/v1.0.0/logger-config')
# Returns: dict (parsed JSON schema)

# Get config defaults by category/version
config = crucible.get_config_defaults('terminal', 'v1.0.0')
# Returns: dict (parsed YAML/JSON config)

# Stream large assets efficiently
with crucible.open_asset('architecture/fulmen-helper-library-standard.md') as f:
    content = f.read()
```

#### Error Handling with Suggestions

**Location**: `src/pyfulmen/crucible/errors.py`

```python
from pyfulmen.crucible import AssetNotFoundError

try:
    schema = crucible.load_schema_by_id('observabilty/logging/v1.0.0/config')  # typo
except AssetNotFoundError as e:
    print(f"Asset not found: {e.asset_id}")
    print(f"Did you mean: {', '.join(e.suggestions)}")
    # Output: observability/logging/v1.0.0/logger-config
```

**Similarity Algorithm**: Uses difflib.SequenceMatcher to find up to 3 similar asset IDs with ratio > 0.6.

#### Recursive Discovery

**Implementation**: `src/pyfulmen/crucible/bridge.py:_discover_categories()`

```python
# Automatically discovers nested structure:
schemas/
‚îú‚îÄ‚îÄ observability/
‚îÇ   ‚îî‚îÄ‚îÄ logging/
‚îÇ       ‚îî‚îÄ‚îÄ v1.0.0/
‚îÇ           ‚îú‚îÄ‚îÄ logger-config.schema.json
‚îÇ           ‚îî‚îÄ‚îÄ logging-policy.schema.json
‚îú‚îÄ‚îÄ library/
‚îÇ   ‚îî‚îÄ‚îÄ foundry/
‚îÇ       ‚îî‚îÄ‚îÄ v1.0.0/
‚îÇ           ‚îî‚îÄ‚îÄ mime-types.schema.json
‚îî‚îÄ‚îÄ ascii/
    ‚îî‚îÄ‚îÄ v1.0.0/
        ‚îî‚îÄ‚îÄ box-chars.schema.json

# Returns asset IDs:
# - observability/logging/v1.0.0/logger-config
# - observability/logging/v1.0.0/logging-policy
# - library/foundry/v1.0.0/mime-types
# - ascii/v1.0.0/box-chars
```

**Prefix Filtering**: Applies to full asset ID path, enabling hierarchical filtering.

#### Testing

**Coverage**: 21 integration tests, 321 unit tests (bridge models and APIs)

- Asset discovery tests (8 tests): category listing, prefix filtering, recursive discovery
- Schema loading tests (5 tests): by ID, error handling, suggestions
- Config loading tests (4 tests): by category/version, path resolution
- Streaming tests (2 tests): context manager, large files
- Version metadata tests (2 tests): parsing, timestamp validation

**Location**: `tests/integration/crucible/test_bridge_integration.py`, `tests/unit/crucible/bridge/`

---

### Docscribe Module

Standalone documentation processing with frontmatter parsing, format detection, and header extraction.

#### Core Features

**Location**: `src/pyfulmen/docscribe/`

- **Frontmatter Parsing**: Extract YAML headers from markdown documents
- **Format Detection**: Identify json, yaml, markdown, toml, multi-document formats
- **Header Extraction**: Parse markdown structure with GitHub-compatible anchors
- **Outline Generation**: Create nested table of contents from headers
- **Header Search**: Find headers matching patterns
- **Document Inspection**: Get format, line count, header count, section estimation

#### Frontmatter Parsing API

**Location**: `src/pyfulmen/docscribe/frontmatter.py`

```python
from pyfulmen import docscribe

# Parse frontmatter and get clean markdown
content, metadata = docscribe.parse_frontmatter(doc)
# content: markdown without frontmatter
# metadata: dict or None

# Get metadata only
metadata = docscribe.extract_metadata(doc)
# Returns: dict with frontmatter fields or None

# Strip frontmatter (discard metadata)
clean = docscribe.strip_frontmatter(doc)
# Returns: markdown without YAML header

# Check for frontmatter presence
has_fm = docscribe.has_frontmatter(doc)
# Returns: bool
```

**Frontmatter Format**:

```markdown
---
title: "My Document"
author: "Jane Doe"
date: "2025-10-21"
status: "stable"
tags: ["python", "documentation"]
---

# Document Content

The actual markdown starts here...
```

**Smart Parsing**: Distinguishes YAML frontmatter (`---\n...\n---\n`) from YAML document separators (`---` in stream context).

#### Format Detection API

**Location**: `src/pyfulmen/docscribe/formats.py`

```python
from pyfulmen import docscribe

# Detect document format
fmt = docscribe.detect_format(content)
# Returns: 'json', 'yaml', 'markdown', 'toml', 'multi-document', or 'unknown'

# Split multi-document streams
documents = docscribe.split_documents(yaml_stream)
# For YAML: splits on '---' separators
# For markdown: splits concatenated docs

# Inspect document metadata
info = docscribe.inspect_document(content)
print(f"Format: {info.format}")
print(f"Lines: {info.line_count}")
print(f"Headers: {info.header_count}")
print(f"Estimated sections: {info.section_count}")
```

**DocumentInfo Model**:

```python
class DocumentInfo(FulmenDataModel):
    """Metadata about a document."""
    format: str  # Detected format
    line_count: int  # Number of lines
    header_count: int  # Number of markdown headers
    section_count: int  # Estimated sections (h1-h3 only)
```

#### Header Extraction API

**Location**: `src/pyfulmen/docscribe/headers.py`

```python
from pyfulmen import docscribe

# Extract all headers with metadata
headers = docscribe.extract_headers(markdown)
for h in headers:
    print(f"{'  ' * (h.level - 1)}{h.text} (#{h.anchor}, line {h.line_number})")

# Generate nested outline structure
outline = docscribe.generate_outline(markdown, max_depth=3)
# Returns: list of dicts with nested structure

# Search for headers matching pattern
results = docscribe.search_headers(markdown, pattern="API")
# Returns: list of DocumentHeader objects
```

**DocumentHeader Model**:

```python
class DocumentHeader(FulmenDataModel):
    """Markdown header metadata."""
    level: int  # Header level (1-6)
    text: str  # Header text
    anchor: str  # GitHub-compatible anchor
    line_number: int  # Line number in document
```

**GitHub-Compatible Anchors**:

- Lowercase conversion
- Special characters ‚Üí hyphens
- Preserves double-hyphens (e.g., `Three-Layer Config` ‚Üí `three-layer-config`)
- Multiple consecutive hyphens collapsed to two
- Handles Unicode characters

#### Crucible Integration

**Location**: `src/pyfulmen/crucible/__init__.py`

```python
from pyfulmen import crucible

# Get clean markdown (frontmatter stripped)
doc = crucible.get_documentation('standards/observability/logging.md')
# Returns: str (markdown only)

# Get metadata only
metadata = crucible.get_documentation_metadata('standards/observability/logging.md')
print(f"Status: {metadata['status']}")
print(f"Tags: {metadata['tags']}")

# Get both together (more efficient)
content, metadata = crucible.get_documentation_with_metadata('guides/bootstrap-goneat.md')
if metadata:
    print(f"Author: {metadata.get('author', 'Unknown')}")
display(content)
```

**Legacy API Compatibility**:

```python
from pyfulmen.crucible import docs

# Legacy API - returns raw content WITH frontmatter
raw = docs.read_doc('standards/observability/logging.md')
assert raw.startswith('---')  # Includes frontmatter

# New API - returns clean content WITHOUT frontmatter
clean = crucible.get_documentation('standards/observability/logging.md')
assert not clean.startswith('---')  # Frontmatter stripped
```

#### Testing

**Coverage**: 92 unit tests, 12 integration tests, 95% coverage

- Frontmatter parsing tests (25 tests): valid/invalid YAML, edge cases, empty metadata
- Format detection tests (18 tests): json, yaml, markdown, toml, multi-doc, unknown
- Header extraction tests (30 tests): all levels, anchors, nesting, edge cases
- Outline generation tests (12 tests): depth limits, nested structure, empty docs
- Search tests (7 tests): pattern matching, case sensitivity, regex support
- Integration tests (12 tests): real Crucible docs, performance benchmarks

**Location**: `tests/unit/docscribe/`, `tests/integration/crucible/test_documentation_integration.py`

**Performance**:

- Frontmatter extraction: <10ms per document average
- 100 iterations: <1s total
- Header extraction: <5ms per document
- Tested with documents up to 20,000 lines

---

## üì¶ Infrastructure & Documentation

### Crucible Overview Section

**Location**: `docs/pyfulmen_overview.md` (lines 33-47)

Added mandatory **Crucible Overview** section per [Fulmen Helper Library Standard](docs/crucible-py/architecture/fulmen-helper-library-standard.md):

**What is Crucible?**

Crucible is the FulmenHQ single source of truth (SSOT) for schemas, standards, and configuration templates. It ensures consistent APIs, documentation structures, and behavioral contracts across all language foundations (gofulmen, pyfulmen, tsfulmen, etc.).

**Why the Shim & Docscribe Module?**

Rather than copying Crucible assets into every project, helper libraries provide idiomatic access through shim APIs. This keeps your application lightweight, versioned correctly, and aligned with ecosystem-wide standards. The docscribe module lets you discover, parse, and validate Crucible content programmatically without manual file management.

**Where to Learn More**:

- [Crucible Repository](https://github.com/fulmenhq/crucible) - SSOT schemas, docs, and configs
- [Fulmen Technical Manifesto](docs/crucible-py/architecture/fulmen-technical-manifesto.md) - Philosophy and design principles
- [SSOT Sync Standard](docs/crucible-py/standards/library/modules/ssot-sync.md) - How libraries stay synchronized

### Synced Crucible Assets

**Updated from Crucible SSOT**:

- `docs/crucible-py/standards/library/modules/docscribe.md` - Docscribe module standard (411 lines)
- `docs/crucible-py/architecture/fulmen-forge-workhorse-standard.md` - Workhorse standard (282 lines)
- `docs/crucible-py/architecture/fulmen-helper-library-standard.md` - Added Crucible Overview requirement
- `docs/crucible-py/architecture/modules/README.md` - Module index with docscribe entry
- `config/crucible-py/library/v1.0.0/module-manifest.yaml` - Added docscribe module entry
- `schemas/crucible-py/library/module-manifest/v1.0.0/module-manifest.schema.json` - Schema updates

### Module Catalog Updates

**Location**: `docs/pyfulmen_overview.md`

| Module ID         | Status    | Coverage Target | Specification                                                       | Description                                                                       |
| ----------------- | --------- | --------------- | ------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **crucible-shim** | ‚úÖ Stable | 90%             | [Spec](docs/crucible-py/standards/library/modules/crucible-shim.md) | Idiomatic Python access to Crucible schemas, docs, and config defaults via bridge |
| **docscribe**     | ‚úÖ Stable | 95%             | [Spec](docs/crucible-py/standards/library/modules/docscribe.md)     | Frontmatter parsing, header extraction, and clean content access (v0.1.4+)        |

---

## üîß Implementation Details

### Bridge API Design Decisions

**Recommended Pattern**: Bridge API is the preferred interface for new code, but legacy APIs remain supported for backward compatibility.

**Why Unified API?**

- **Simplicity**: Single import point (`from pyfulmen import crucible`)
- **Discovery**: List available assets without knowing directory structure
- **Consistency**: Same patterns for schemas, configs, and docs
- **Error Handling**: Similarity suggestions reduce typo frustration
- **Extensibility**: Easy to add new asset categories

**Asset ID Format**:

- **Schemas**: `category/version/name` (e.g., `observability/logging/v1.0.0/logger-config`)
- **Config**: `category/version` (e.g., `terminal/v1.0.0`)
- **Docs**: `path/to/doc.md` (e.g., `standards/observability/logging.md`)

### Docscribe Design Decisions

**Standalone Module**: Docscribe is a separate module from `crucible` to enable:

- Direct use without Crucible integration
- Generic markdown processing for any documentation
- Clear separation of concerns (asset access vs. content processing)
- Potential future extraction as separate package

**Frontmatter-First**: Parse frontmatter before content to:

- Support metadata-driven workflows
- Enable clean rendering without YAML noise
- Allow schema validation of metadata
- Provide structured document discovery

**GitHub-Compatible Anchors**: Preserve double-hyphens to match GitHub's anchor generation, ensuring links work in both PyFulmen docs and GitHub-rendered markdown.

### Crucible Delegation Pattern

**Location**: `src/pyfulmen/crucible/docs.py`

The existing `crucible.docs` module now delegates to docscribe internally:

```python
def get_documentation(path: str) -> str:
    """Get documentation with frontmatter stripped."""
    raw = read_doc(path)
    clean, _ = parse_frontmatter(raw)
    return clean

def get_documentation_metadata(path: str) -> dict | None:
    """Get frontmatter metadata only."""
    raw = read_doc(path)
    return extract_metadata(raw)
```

**Benefits**:

- Single implementation of frontmatter parsing
- Legacy APIs automatically benefit from docscribe enhancements
- Clear upgrade path: use bridge API for new code
- No breaking changes to existing code

---

## üìä Quality Metrics

### Test Coverage

- **Bridge Tests**: 21 integration tests, 321 unit tests
- **Docscribe Tests**: 92 unit tests, 12 integration tests
- **Total Tests**: 845 passing, 18 skipped (+113 tests from v0.1.3)
- **Coverage**: 90%+ maintained across all modules, 95% on docscribe

### Code Quality

- ‚úÖ Ruff linting: All checks passing
- ‚úÖ Ruff formatting: Code formatted consistently
- ‚úÖ Type hints: Full type coverage maintained
- ‚úÖ Documentation: Complete and validated

### Performance

**Docscribe Benchmarks**:

- Frontmatter extraction: <10ms per document (avg: 5.2ms)
- Header extraction: <5ms per document (avg: 2.8ms)
- 100 document batch: <1s total processing time
- Memory efficient: streams large files via context manager

**Bridge API Benchmarks**:

- Asset listing: <5ms for full catalog scan
- Schema loading: <2ms per schema
- Recursive discovery: <20ms for all categories
- Suggestion generation: <1ms via difflib

---

## üöÄ Getting Started

### Crucible Bridge API Usage

```python
from pyfulmen import crucible

# Discover what's available
categories = crucible.list_categories()
print(f"Asset categories: {categories}")

# List schemas with prefix filter
logging_schemas = crucible.list_assets('schemas', prefix='observability/logging')
for schema_id in logging_schemas:
    print(f"Found schema: {schema_id}")

# Load schema by ID
schema = crucible.load_schema_by_id('observability/logging/v1.0.0/logger-config')
print(f"Schema title: {schema.get('title')}")

# Get config defaults
terminal_config = crucible.get_config_defaults('terminal', 'v1.0.0')
print(f"Terminal profiles: {len(terminal_config['profiles'])}")

# Stream large documentation files
with crucible.open_asset('architecture/fulmen-helper-library-standard.md') as f:
    content = f.read()
    print(f"Standard is {len(content)} bytes")

# Get Crucible version
version = crucible.get_crucible_version()
print(f"Using Crucible {version.version} synced at {version.sync_timestamp}")
```

### Docscribe Usage

```python
from pyfulmen import docscribe

# Read markdown file
with open('docs/example.md') as f:
    raw_content = f.read()

# Parse frontmatter
clean_content, metadata = docscribe.parse_frontmatter(raw_content)

if metadata:
    print(f"Title: {metadata.get('title')}")
    print(f"Author: {metadata.get('author')}")
    print(f"Tags: {', '.join(metadata.get('tags', []))}")

# Extract headers for navigation
headers = docscribe.extract_headers(clean_content)
for header in headers:
    indent = '  ' * (header.level - 1)
    print(f"{indent}- {header.text} (line {header.line_number})")

# Generate table of contents
outline = docscribe.generate_outline(clean_content, max_depth=3)
# Returns nested structure suitable for rendering

# Search for specific headers
api_sections = docscribe.search_headers(clean_content, pattern='API')
for section in api_sections:
    print(f"Found API section: {section.text} at line {section.line_number}")

# Inspect document
info = docscribe.inspect_document(raw_content)
print(f"Format: {info.format}")
print(f"Lines: {info.line_count}")
print(f"Headers: {info.header_count}")
```

### Crucible + Docscribe Integration

```python
from pyfulmen import crucible

# Get documentation with frontmatter handling
doc, metadata = crucible.get_documentation_with_metadata(
    'standards/observability/logging.md'
)

if metadata:
    print(f"Reading {metadata['title']} by {metadata.get('author', 'Unknown')}")
    print(f"Status: {metadata['status']}")
    print(f"Last updated: {metadata.get('last_updated', 'N/A')}")

# Render clean markdown (no YAML noise)
render_to_html(doc)

# Or get just the metadata
metadata = crucible.get_documentation_metadata('guides/bootstrap-goneat.md')
if metadata and metadata.get('status') == 'stable':
    print("‚úÖ This guide is production-ready")
```

---

## üîÑ Migration Guide

### From v0.1.3 to v0.1.4

**No breaking changes** - this release is fully backward compatible.

### New Recommended Patterns

**Bridge API** (Recommended for new code):

```python
# OLD (still works, but not recommended)
from pyfulmen.crucible import schemas
schema = schemas.load_schema('observability/logging', 'v1.0.0', 'logger-config')

# NEW (recommended)
from pyfulmen import crucible
schema = crucible.load_schema_by_id('observability/logging/v1.0.0/logger-config')
```

**Documentation with Frontmatter**:

```python
# OLD (still works, includes frontmatter)
from pyfulmen.crucible import docs
raw = docs.read_doc('standards/observability/logging.md')
# raw includes YAML header

# NEW (recommended, clean content)
from pyfulmen import crucible
content = crucible.get_documentation('standards/observability/logging.md')
# content is clean markdown without frontmatter
metadata = crucible.get_documentation_metadata('standards/observability/logging.md')
# metadata is parsed YAML dict
```

**Docscribe Direct Usage**:

```python
# Use docscribe directly for non-Crucible markdown
from pyfulmen import docscribe

with open('my-doc.md') as f:
    raw = f.read()

clean, metadata = docscribe.parse_frontmatter(raw)
headers = docscribe.extract_headers(clean)
outline = docscribe.generate_outline(clean, max_depth=2)
```

### Dependencies

No new dependencies in this release. All features use existing dependencies (Pydantic, PyYAML).

---

## üìù Known Limitations

### Docscribe Phase 2

**Deferred to v0.1.5**:

- Config loading with frontmatter validation
- `crucible.load_config()` convenience wrapper
- Schema validation of frontmatter metadata

**Current Workaround**:

```python
from pyfulmen.config.loader import ConfigLoader
from pyfulmen.schema.validator import validate_data

# Load config using three-layer system
loader = ConfigLoader()
config = loader.load('observability/logging/v1.0.0/logging-policy')

# Validate metadata manually if needed
metadata = crucible.get_documentation_metadata('some-doc.md')
if metadata:
    result = validate_data('metadata-schema-id', metadata)
    if not result.is_valid:
        print("Invalid frontmatter")
```

### General

- **Windows Testing**: Best-effort Windows support, primarily tested on macOS/Linux
- **Large Document Performance**: Documents >100K lines not yet benchmarked
- **Frontmatter Complexity**: Only YAML frontmatter supported (no TOML/JSON)

---

## ü§ù Contributors

**Generated by**: PyFulmen Architect (@pyfulmen-architect) using [Claude Code](https://claude.ai/code)
**Supervised by**: @3leapsdave (Dave Thompson)
**Agentic Attribution**: All commits follow FulmenHQ agentic attribution standards

---

## üìö Additional Resources

- **Repository**: [pyfulmen](https://github.com/fulmenhq/pyfulmen) (internal)
- **Bridge API Documentation**: `src/pyfulmen/crucible/bridge.py` (comprehensive docstrings)
- **Docscribe Documentation**: `src/pyfulmen/docscribe/README.md`
- **Docscribe Standard**: `docs/crucible-py/standards/library/modules/docscribe.md`
- **Crucible Shim Standard**: `docs/crucible-py/standards/library/modules/crucible-shim.md`
- **PyFulmen Overview**: `docs/pyfulmen_overview.md` (includes Crucible overview)
- **Maintainers**: See `MAINTAINERS.md` for project governance

---

## üéØ Next Steps

### v0.1.5 (Planned)

Docscribe Phase 2 and config enhancements:

- `crucible.load_config()` convenience wrapper
- Frontmatter schema validation
- Config loading with metadata awareness
- TOML frontmatter support
- Enhanced outline generation (custom depth per level)

### v0.2.0 (Planned - Q1 2026)

Enterprise observability and performance:

- Enhanced correlation ID propagation (HTTP headers, gRPC metadata)
- Tracing integration (OpenTelemetry compatibility)
- External sink support (HTTP/HTTPS log shipping)
- Performance optimizations for high-throughput logging
- Async logging support for high-throughput services

### v0.3.0+ (Future)

Extended ecosystem utilities:

- Cloud storage helpers (S3/GCS/Azure)
- Metrics and tracing modules (full observability stack)
- Enhanced CLI tooling integration
- Performance benchmarks and optimization
- Additional ASCII formatters (tables, progress bars)

---

**Release**: v0.1.4
**Date**: October 21, 2025
**Status**: ‚úÖ Released
